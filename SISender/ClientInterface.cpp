#include "stdafx.h"
#include "ClientInterface.h"

CClientInterface::CClientInterface()
{
	m_bConnecting = false;
	m_dwLastTime = 0;
	m_dwLastConnected = 0;
	InitializeCriticalSection(&mConnectionCheck);

	CEncDec::New();
}

CClientInterface::~CClientInterface()
{
	CEncDec::Delete();
}

void CClientInterface::Destroy()
{
	DeleteCriticalSection(&mConnectionCheck);
}

bool CClientInterface::TryConnection(const char* ip, u_short port)
{
	EnterCriticalSection(&mConnectionCheck);

	strcpy_s(m_ip, 32, ip);
	m_port = port;

	if (!m_bConnecting)
	{
		m_bConnecting = true;

		if (Network::Initialize() == false)
		{
			LeaveCriticalSection(&mConnectionCheck);
			m_bConnecting = false;
			return false;
		}
		ClientMan::New();

		ClientMan::Instance()->AddClients(1);
		ClientMan::Instance()->ConnectClients(ip, port);
	}

	LeaveCriticalSection(&mConnectionCheck);
	return true;
}

bool CClientInterface::TryShutdown()
{
	EnterCriticalSection(&mConnectionCheck);

	if (m_bConnecting)
	{
		m_bConnecting = false;

		ClientMan::Instance()->RemoveClients();
		ClientMan::Delete();
		Network::Deinitialize();

		m_dwLastConnected = GetTickCount();
	}
	LeaveCriticalSection(&mConnectionCheck);

	return true;
}

bool CClientInterface::IsConnected()
{
	EnterCriticalSection(&mConnectionCheck);

	if (ClientMan::Instance()->GetClientState() == Client::CONNECTED)
	{
		LeaveCriticalSection(&mConnectionCheck);
		return true;
	}
	LeaveCriticalSection(&mConnectionCheck);
	return false;
}

bool CClientInterface::Send(const char* msg)
{
	EnterCriticalSection(&mConnectionCheck);

	if (ClientMan::Instance()->GetNumClients() > 0)
	{
		ClientMan::Instance()->Send(msg);
	}
	else if(GetTickCount() - m_dwLastConnected >= 3000)
	{
		m_bConnecting = true;

		if (Network::Initialize() == false)
		{
			LeaveCriticalSection(&mConnectionCheck);
			m_bConnecting = false;
			return false;
		}
		ClientMan::New();

		ClientMan::Instance()->AddClients(1);
		ClientMan::Instance()->ConnectClients(m_ip, m_port);

		LeaveCriticalSection(&mConnectionCheck);
		return false;
	}

	LeaveCriticalSection(&mConnectionCheck);

	return true;
}

bool CClientInterface::Send(BYTE* buffer, int nSize)
{
	EnterCriticalSection(&mConnectionCheck);

	if (ClientMan::Instance()->GetNumClients() > 0)
	{
		ClientMan::Instance()->Send(buffer, nSize);
	}
	else if (GetTickCount() - m_dwLastConnected >= 3000)
	{
		m_bConnecting = true;

		if (Network::Initialize() == false)
		{
			LeaveCriticalSection(&mConnectionCheck);
			m_bConnecting = false;
			return false;
		}
		ClientMan::New();

		ClientMan::Instance()->AddClients(1);
		ClientMan::Instance()->ConnectClients(m_ip, m_port);

		LeaveCriticalSection(&mConnectionCheck);
		return false;
	}

	LeaveCriticalSection(&mConnectionCheck);
	return true;
}

void CClientInterface::ProcessCommonRequest(USHORT protocol, int nValue)
{
	ProtocolRequest req;
	req.protocol = protocol;
	req.nValue = nValue;

	if (ProtocolHeader::Keep_Alive != protocol) {
		Log::Trace("ProcessCommonRequest: protocol: %d / value: %d", protocol, nValue);
	}

	Send((BYTE*)&req, sizeof(ProtocolRequest));
}

void CClientInterface::ProcessRequestLogin(WCHAR* szID, WCHAR* szPW)
{
	ProtocolRequestLogin login;
	strcpy_s(login.szID, CCommonFunc::WcharToUtf8(szID));
	strcpy_s(login.szPW, CCommonFunc::WcharToUtf8(szPW));

	Log::Trace("로그인 요청(%s)", login.szID);

	CEncDec::Instance()->PacketEncode((BYTE*)&login, sizeof(ProtocolHeader), sizeof(ProtocolRequestLogin) - sizeof(ProtocolHeader));
	Send((BYTE*)&login, sizeof(ProtocolRequestLogin));
}

void CClientInterface::ProcessRequestAddEvent(int idx, CHAR* szID, CHAR* szEvent, int nCount)
{
	ProtocolRequestAddEvent event;
	event.idx = idx;
	strcpy_s(event.szID, szID);
	strcpy_s(event.szEvent, szEvent);

	Log::Trace("이벤트 정보 저장 요청(요청 갯수: %d)", nCount);// (%s)", CCommonFunc::Utf8ToChar(szEvent));

	Send((BYTE*)&event, sizeof(ProtocolRequestAddEvent));
}

//Kocom

void CClientInterface::KOCOMProcessRequestBind(CHAR* szID, CHAR* szPW)
{
	KOCOMProtocolBind bind;
	bind.header.headerKey = KOCOM_HEADER_KEY_VALUE;
	bind.header.msgType = KOCOM_FIRE_TYPE | KOCOM_MSG_BIND;
	bind.header.msgLength = sizeof(KOCOMProtocolBind) - sizeof(KOCOMProtocolHeader);

	strcpy_s(bind.szId, szID);
	strcpy_s(bind.szPass, szPW);

	Log::Trace("ID : %s, PW : %s Kocom Bind Request", szID, szPW);

	Send((BYTE*)&bind, sizeof(KOCOMProtocolBind));
}

void CClientInterface::KOCOMProcessRequestAlive()
{
	KOCOMProtocolAlive alive;
	alive.header.headerKey = KOCOM_HEADER_KEY_VALUE;
	alive.header.msgType = KOCOM_FIRE_TYPE | KOCOM_MSG_ALIVE;
	alive.header.msgLength = sizeof(KOCOMProtocolAlive) - sizeof(KOCOMProtocolHeader);

	alive.homeVersion = 0;
	alive.nKind = 0;		//프로토콜 문서에서는 별첨을 참조하라고 되어 있는데 별첨이 없음
	alive.nVersion[0] = 0;
	alive.nVersion[1] = 0;
	alive.nVersion[2] = 0;
	alive.nVersion[3] = 0;

	Send((BYTE*)&alive, sizeof(KOCOMProtocolAlive));
}

void CClientInterface::KOCOMProcessRequestFireAlarm(BYTE* pData)
{
	KOCOMProtocolFireAlarm alarm;
	alarm.header.headerKey = KOCOM_HEADER_KEY_VALUE;
	alarm.header.msgType = KOCOM_FIRE_TYPE | KOCOM_MSG_FIRE_ALARM;
	alarm.header.msgLength = sizeof(KOCOMProtocolFireAlarm) - sizeof(KOCOMProtocolHeader);
	alarm.header.town = 0;
	alarm.header.dong = 101;
	alarm.header.ho = 0;
	alarm.header.reserved = 0;

	//화재 타입 정의
	CString strFireType = _T("");
	int nFireType = 0;
	if (pData[SI_EVENT_BUF_COMMAND] == 'R')
	{
		strFireType = _T("화재 일괄 해제");
		nFireType = KOCOM_FIRE_ALARM_ALL_CLEAR;
	}
	//else if((pData[SI_EVENT_BUF_COMMAND] == 'F') && (pData[SI_EVENT_BUF_FIRE_RECEIVER_1] == '0'))		//김호 마스터 확인 결과 두번째 조건을 필요 없음
	else if (pData[SI_EVENT_BUF_COMMAND] == 'F')
	{
		if (pData[SI_EVENT_BUF_OCCUR_INFO] == 'N')
		{
			strFireType = _T("화재 발생");
			nFireType = KOCOM_FIRE_ALARM_FIRE_OCCURED;
		}
		else if (pData[SI_EVENT_BUF_OCCUR_INFO] == 'F')
		{
			strFireType = _T("화재 해제");
			nFireType = KOCOM_FIRE_ALARM_FIRE_CLEAR;
		}
		else
		{
			Log::Trace("화재 타입이 아닌 이벤트가 들어왔습니다. KOCOM 이벤트 전송을 하지 않습니다.");
			return;		// N이나 F가 아니면 리턴
		}
	}
	else
	{
		Log::Trace("화재 타입이나 수신기 복구 이외의 이벤트가 들어왔습니다. KOCOM 이벤트 전송을 하지 않습니다.");
		return;		//화재 타입이나 수신기 복구가 아니면 리턴
	}

	//건물 정보 - 회로 정보 매칭을 통해 위치 정보 확인
	int nFDong = 101;
	int nFHo = 101;
	int nFFloor = 1;
	int nFloorType = FLOOR_TYPE_ETC;

	//회로번호와 건물정보 매칭
	CString strCircuitNo = _T("");
	strCircuitNo = CCircuitLocInfo::Instance()->GetCircuitNo(pData);

	std::map<CString, CIRCUIT_LOC_INFO>::iterator iter;
	CIRCUIT_LOC_INFO cli;
	//수신기 복구는 위치정보에 없음, 
	if (strCircuitNo.Compare(_T("00000000")) != 0)
	{
		iter = CCircuitLocInfo::Instance()->m_mapCircuitLocInfo.find(strCircuitNo);

		//위치정보에서 찾으면 
		if (iter != CCircuitLocInfo::Instance()->m_mapCircuitLocInfo.end())
		{
			cli = iter->second;
			if (nFireType != KOCOM_FIRE_ALARM_ALL_CLEAR)
			{
				alarm.header.dong = nFDong = atoi(cli.buildingName);
			}

			//일단 아파트 건물(101동, 102동 등의 건물이 아닌 주차장 등의 건물은 이벤트 안보내도록 코콤과 협의됨)
			if (nFDong == 0)
			{
				Log::Trace("아파트 건물 외의 기타 건물의 화재 정보가 들어왔습니다. KOCOM 이벤트 전송을 하지 않습니다.");
				return;
			}

			nFloorType = CCircuitLocInfo::Instance()->CheckFloorType(cli.floor);

			if (nFloorType == FLOOR_TYPE_BASEMENT)
			{	
				nFFloor = atoi(&cli.floor[1]);	// B 이후 숫자 
				nFFloor *= -1;
			}
			else if (nFloorType == FLOOR_TYPE_PH)	// 코콤은 층이 큰 의미가 없고 옥탑층 개념이 없지만 일단 옥탑층 정보를 얻도록 함
			{
				nFFloor = atoi(&cli.floor[2]);	// PH 이후 숫자
			}
			else if (nFloorType == FLOOR_TYPE_M)
			{
				nFFloor = atoi(&cli.floor[1]);	// M 이후 숫자 
			}
			else // 일반층은 그대로 층수 얻고, RF는 어차피 숫자가 없음, 현재 Kocom 프로토콜로 RF 표현 불가능
			{
				nFFloor = atoi(cli.floor);
			}

			//호(실) 정보
			alarm.header.ho = nFHo = atoi(cli.room);

		}
	}
	else //수신기 복구의 경우 빈 정보를 채움
	{
		strcpy(cli.buildingName, "");
		strcpy(cli.circuitName, "");
		strcpy(cli.stair, "");
		strcpy(cli.floor, "");
		strcpy(cli.room, "");
	}
	
	//동정보
	alarm.nAlarm = nFireType;
	alarm.nFDong = nFDong;
	alarm.nFHo = nFHo;
	alarm.nFFloor = nFFloor;

	CString strMsg = _T("");
	CString strTemp = _T("");

	strMsg = _T("#dong:");
	strTemp.Format(_T("%s"), CCommonFunc::CharToWCHAR(cli.buildingName));
	strMsg += strTemp;
	strMsg += _T(",#ho:");
	strTemp.Format(_T("%s"), CCommonFunc::CharToWCHAR(cli.room));
	strMsg += strTemp;
	strMsg += _T(",#floor:");
	strTemp.Format(_T("%s"), CCommonFunc::CharToWCHAR(cli.floor));
	strMsg += strTemp;

	strcpy_s(alarm.szFMsg, CCommonFunc::WcharToUtf8(strMsg.GetBuffer(0)));	//한글포함 시 UTF-8 처리

	CHAR cMsg[80];
	memset(cMsg, NULL, 80);
	strcpy_s(cMsg, CCommonFunc::WCharToChar(strFireType.GetBuffer(0)));

	switch (nFloorType)
	{
	case FLOOR_TYPE_BASEMENT:
	{
		Log::Trace("%d동 B%d층 %d호 %s [%s]", nFDong, nFFloor * -1, nFHo, cMsg, CCommonFunc::WCharToChar(strMsg.GetBuffer(0)));
		break;
	}
	case FLOOR_TYPE_NORMAL:
	{
		Log::Trace("%d동 %d층 %d호 %s [%s]", nFDong, nFFloor, nFHo, cMsg, CCommonFunc::WCharToChar(strMsg.GetBuffer(0)));
		break;
	}
	case FLOOR_TYPE_RF:
	{
		Log::Trace("%d동 RF층 %s %s [%s]", nFDong, cli.room, cMsg, CCommonFunc::WCharToChar(strMsg.GetBuffer(0)));
		break;
	}
	case FLOOR_TYPE_PH:
	{
		Log::Trace("%d동 PH%d층 %s %s [%s]", nFDong,  nFFloor, cli.room, cMsg, CCommonFunc::WCharToChar(strMsg.GetBuffer(0)));
		break;
	}
	case FLOOR_TYPE_PIT:
	{
		Log::Trace("%d동 PIT층 %s %s [%s]", nFDong, cli.room, cMsg, CCommonFunc::WCharToChar(strMsg.GetBuffer(0)));
		break;
	}
	case FLOOR_TYPE_M:
	{
		Log::Trace("%d동 M%d층 %s호 %s [%s]", nFDong, nFFloor, cli.room, cMsg, CCommonFunc::WCharToChar(strMsg.GetBuffer(0)));
		break;
	}
	case FLOOR_TYPE_ETC:
	default:
	{
		Log::Trace("%d동 %s [%s]", nFDong, cMsg, CCommonFunc::WCharToChar(strMsg.GetBuffer(0)));
		break;
	}
	}

	Send((BYTE*)&alarm, sizeof(KOCOMProtocolFireAlarm));
}

void CClientInterface::COMMAXProcessRequestFireAlarm(BYTE* pData)
{
	//기존 연결 존재하면 연결 해제
	TryShutdown();

	//통신 연결
	TryConnection(CCommonState::Instance()->m_szServerIP, CCommonState::Instance()->m_nPort);

	//버퍼 가공
	//화재 타입 정의
	CString strFireType = _T("");
	int nFireType = 0;
	if (pData[SI_EVENT_BUF_COMMAND] == 'R')
	{
		strFireType = _T("화재 일괄 해제");
		nFireType = COMMAX_FIRE_ALARM_ALL_CLEAR;
	}
	//else if((pData[SI_EVENT_BUF_COMMAND] == 'F') && (pData[SI_EVENT_BUF_FIRE_RECEIVER_1] == '0'))		//김호 마스터 확인 결과 두번째 조건을 필요 없음
	else if (pData[SI_EVENT_BUF_COMMAND] == 'F')
	{
		if (pData[SI_EVENT_BUF_OCCUR_INFO] == 'N')
		{
			strFireType = _T("화재 발생");
			nFireType = COMMAX_FIRE_ALARM_FIRE_OCCURED;
		}
		else if (pData[SI_EVENT_BUF_OCCUR_INFO] == 'F')
		{
			strFireType = _T("화재 해제");
			nFireType = COMMAX_FIRE_ALARM_FIRE_CLEAR;
		}
		else
		{
			Log::Trace("화재 타입이 아닌 이벤트가 들어왔습니다. COMMAX 이벤트 전송을 하지 않습니다.");
			return;		// N이나 F가 아니면 리턴
		}
	}
	else
	{
		Log::Trace("화재 타입이나 수신기 복구 이외의 이벤트가 들어왔습니다. COMMAX 이벤트 전송을 하지 않습니다.");
		return;		//화재 타입이나 수신기 복구가 아니면 리턴
	}

	//건물 정보 - 회로 정보 매칭을 통해 위치 정보 확인
	int nDong = 0;
	int nFloor = 0;
	int nStair = 0;
	int nFloorType = FLOOR_TYPE_ETC;

	//회로번호와 건물정보 매칭
	CString strCircuitNo = _T("");
	strCircuitNo = CCircuitLocInfo::Instance()->GetCircuitNo(pData);

	std::map<CString, CIRCUIT_LOC_INFO>::iterator iter;
	CIRCUIT_LOC_INFO cli;
	//수신기 복구는 위치정보에 없음, 
	if (strCircuitNo.Compare(_T("00000000")) != 0)
	{
		iter = CCircuitLocInfo::Instance()->m_mapCircuitLocInfo.find(strCircuitNo);

		//위치정보에서 찾으면 
		if (iter != CCircuitLocInfo::Instance()->m_mapCircuitLocInfo.end())
		{
			cli = iter->second;
			if (nFireType != COMMAX_FIRE_ALARM_ALL_CLEAR)
			{
				nDong = atoi(cli.buildingName);
			}

			//일단 아파트 건물(101동, 102동 등의 건물이 아닌 주차장 등의 건물은 전송안함)
			if (nDong == 0)
			{
				Log::Trace("아파트 건물 외의 기타 건물의 화재 정보가 들어왔습니다. COMMAX 이벤트 전송을 하지 않습니다.");
				return;
			}

			nFloorType = CCircuitLocInfo::Instance()->CheckFloorType(cli.floor);

			if (nFloorType == FLOOR_TYPE_BASEMENT)
			{
				nFloor = atoi(&cli.floor[1]);	// B 이후 숫자 
				nFloor *= -1;
			}
			else if (nFloorType == FLOOR_TYPE_PH)	// COMMAX는 층이 큰 의미가 없고 옥탑층 개념이 없지만 일단 옥탑층 정보를 얻도록 함
			{
				nFloor = atoi(&cli.floor[2]);	// PH 이후 숫자
			}
			else if (nFloorType == FLOOR_TYPE_M)
			{
				nFloor = atoi(&cli.floor[1]);	// M 이후 숫자 
			}
			else // 일반층은 그대로 층수 얻고, RF는 어차피 숫자가 없음, 현재 COMMAX 프로토콜로 RF 표현 불가능
			{
				nFloor = atoi(cli.floor);
			}

			nStair = atoi(cli.stair);

			//호(실) 정보는 COMMAX 프로토콜에 없음
		}

	}
	else //수신기 복구
	{

	}

	CString strBuf = _T("");

	if (nFireType != COMMAX_FIRE_ALARM_ALL_CLEAR)
	{
		CString strDong = _T("");
		if (nDong != 0)
		{
			strDong.Format(_T("%d"), nDong);
		}

		CString strFloor = _T("");
		if (nFloor != 0)
		{
			strFloor.Format(_T("%d"), nFloor);
		}

		CString strStair = _T("");
		if (nStair != 0)
		{
			strStair.Format(_T("%d"), nStair);
		}

		strBuf.Format(_T("%s\r\n\t%s\r\n\t\t%s%d%s\r\n\t\t%s%s%s\r\n\t\t%s%s%s\r\n\t\t%s%s%s\r\n\t\t%s%s%s\r\n\t%s\r\n%s")
			, g_lpszCommaxTagName[XML_TAG_START_COMMAX]
			, g_lpszCommaxTagName[XML_TAG_START_FIRE]
			, g_lpszCommaxTagName[XML_TAG_START_EMERGENCY]
			, nFireType
			, g_lpszCommaxTagName[XML_TAG_END_EMERGENCY]
			, g_lpszCommaxTagName[XML_TAG_START_DONG]
			, strDong
			, g_lpszCommaxTagName[XML_TAG_END_DONG]
			, g_lpszCommaxTagName[XML_TAG_START_FLOOR]
			, strFloor
			, g_lpszCommaxTagName[XML_TAG_END_FLOOR]
			, g_lpszCommaxTagName[XML_TAG_START_STAIR]
			, strStair
			, g_lpszCommaxTagName[XML_TAG_END_STAIR]
			, g_lpszCommaxTagName[XML_TAG_START_LINE]
			, _T("")
			, g_lpszCommaxTagName[XML_TAG_END_LINE]
			, g_lpszCommaxTagName[XML_TAG_END_FIRE]
			, g_lpszCommaxTagName[XML_TAG_END_COMMAX]
		);
	}
	else // COMMAX에서 수신기 복구를 화재해제(2), 동을 ALL로 보내달라고 요청함
	{
		strBuf.Format(_T("%s\r\n\t%s\r\n\t\t%s%d%s\r\n\t\t%s%s%s\r\n\t\t%s%s%s\r\n\t\t%s%s%s\r\n\t\t%s%s%s\r\n\t%s\r\n%s")
			, g_lpszCommaxTagName[XML_TAG_START_COMMAX]
			, g_lpszCommaxTagName[XML_TAG_START_FIRE]
			, g_lpszCommaxTagName[XML_TAG_START_EMERGENCY]
			, COMMAX_FIRE_ALARM_FIRE_CLEAR
			, g_lpszCommaxTagName[XML_TAG_END_EMERGENCY]
			, g_lpszCommaxTagName[XML_TAG_START_DONG]
			, _T("ALL")
			, g_lpszCommaxTagName[XML_TAG_END_DONG]
			, g_lpszCommaxTagName[XML_TAG_START_FLOOR]
			, _T("")
			, g_lpszCommaxTagName[XML_TAG_END_FLOOR]
			, g_lpszCommaxTagName[XML_TAG_START_STAIR]
			, _T("")
			, g_lpszCommaxTagName[XML_TAG_END_STAIR]
			, g_lpszCommaxTagName[XML_TAG_START_LINE]
			, _T("")
			, g_lpszCommaxTagName[XML_TAG_END_LINE]
			, g_lpszCommaxTagName[XML_TAG_END_FIRE]
			, g_lpszCommaxTagName[XML_TAG_END_COMMAX]
		);
	}

	//Send
	int nClientListSize = 0;
	nClientListSize = ClientMan::Instance()->GetNumClients();
	HANDLE hHandle[100];

	for (int i = 0; i < nClientListSize; i++)
	{
		hHandle[i] = ClientMan::Instance()->m_listClient[i]->m_hCommaxConnect;
	}

	DWORD dw = WaitForMultipleObjects(nClientListSize, hHandle, TRUE, 3000);
	if (dw != WAIT_OBJECT_0)
	{
		int a = 0;
	}

	if (m_bConnecting)
	{
		char cBuf[300];
		memset(cBuf, NULL, 300);
		strcpy(cBuf, CCommonFunc::WCharToChar(strBuf.GetBuffer(0)));
		Send((BYTE*)cBuf, strlen(cBuf));
	}
	else
	{
		Log::Trace("통신이 연결되지 않아 화재 이벤트를 전송하지 않습니다.");
	}

	//통신 해제
	TryShutdown();
}